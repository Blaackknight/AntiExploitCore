on load:
    bckManagerLoad()
    wait 1 seconds
    set {sbm} to yaml value "data.money" from "bck.manager.config"
    set {skn} to "§4BCK§r"

    set {spawnCoordinates::*} to getCoordinateSeparate("%{spawn}%")
on inventory close:
    userData(player, "data.inv", "set", "false")
on unload:
    delete {server.perms::*}
    delete {letters::*}
        #send "§c§lHey! §7Tu n'a pas la permission :|"
# every minecraft day in "world":
#     add 1 to {world.day}
#     logCustom("§71§r added to day", 4)
#     logCustom("§71§r added to day", 5)
function bckManagerLoad():
    load yaml "plugins/Skript/scripts/BCK/manager/config.yml" as "bck.manager.config"
    load yaml "plugins/Skript/scripts/BCK/manager/data.yml" as "bck.manager.data"
function bckManagerEditfiles(source: text, find: text="data", mode: text="extract", data: text="") :: text:
	if {_mode} is "extract":
		set {_result} to yaml value "%{_find}%" from "bck.%{_source}%"
		if {_result} isn't set:
			if {_data} isn't empty:
				set {_result} to {_data}
	else if {_mode} is "delete":
		set {_result} to yaml value "%{_find}%" from "bck.%{_source}%"
		if {_result} is set:
			delete yaml value "%{_find}%" from "bck.%{_source}%"
			save yaml "bck.%{_source}%"
	else:
		set yaml value "%{_find}%" from "bck.%{_source}%" to {_data}
		save yaml "bck.%{_source}%"
	return {_result}
function backpackGuiSaver(player: player, gui: inventory):
    set {_i} to {_player}'s tool
    set {_storage::*} to items of {_gui}
    set yaml list "data.inventory.%{_player}'s uuid%.%backpackGetUUID({_i})%" from "bck.manager.backpack.data" to {_storage::*}
    save yaml "bck.manager.backpack.data"
function backpackGetTier(item: item) :: number:
    set {_l} to line 3 of {_item}'s lore
    set {_l} to uncolored {_l}
    replace "⇾ Tier: " with "" in {_l}
    set {_l} to {_l} parsed as number
    return {_l}
function backpackGetUUID(item: item) :: string:
    set {_l} to line 5 of {_item}'s lore
    set {_l} to uncolored {_l}
    return {_l}
on command "/op":
    if player is set:
        if hasPermission(player, "bypass.op", true) is false:
            cancel event
            send lang("core.cannotDoThis", player)
on command "/deop":
    if player is set:
        if hasPermission(player, "bypass.deop", true) is false:
            cancel event
            send lang("core.cannotDoThis", player)
on command "/kick":
    if player is set:
        if hasPermission(player, "bypass.kick", true) is false:
            cancel event
            send lang("core.cannotDoThis", player)
on command "/ban":
    if player is set:
        if hasPermission(player, "bypass.ban", true) is false:
            cancel event
            send lang("core.cannotDoThis", player)
on damage:
    set {_a} to attacker
    if "%type of {_a}%" is "player":
        if hasPermission({_a}, "player.attack") is false:
            cancel event
            send lang("core.noPermission", {_a}) to {_a}
# on place:
#     set {_o} to event-location
#     set {_a} to player
#     set {_b} to event-block
#     addTempBlock(player, {_b})
#     getTempCoordinate(player, {_b})
# on break:
#     set {_o} to event-location
#     set {_a} to player
#     set {_b} to event-block
#     getTempCoordinate(player, {_b})
#     removeTempBlock(player, {_b})
