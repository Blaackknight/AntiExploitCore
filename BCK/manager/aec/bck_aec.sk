on load:
    set {_list::*} to {skripts::*}
    if {_list::*} contains "bck_manager.sk" and "core.sk":
        send "§6[§4BCK§6]§r Loading AntiExploitCore..." to console
        send "§6[§4BCK§6/§aAntiExploitCore§6]§r Loaded successfully !" to console
        load yaml "plugins/Skript/scripts/BCK/manager/aec/config.yml" as "bck.manager.aec.config"
        load yaml "plugins/Skript/scripts/BCK/manager/aec/data.yml" as "bck.manager.aec.data"
        aecLoad()
        set {aec.command.args::*} to "freeze", "endersee", "invsee", "reload", "vanish", "god" and "topluck"
    else:
        broadcast "§6[§4BCK§6/§aAntiExploitCore§6]§r Script loading cancel It requires (core.sk & bck_manager.sk)"
        unload script file "bck_aec.sk"
#                                      AntiExploitCore command                                                                          #
command /AntiExploitCore [<text>] [<text>]:
    aliases: /aec
    trigger:
        if arg-1 is not set:
            send formatted commandError(command, "false", player) to player
        else if {aec.command.args::*} doesn't contain arg-1:
            send formatted commandError(command, arg-1, player) to player
        else if arg-1 is "freeze":
            set {_v} to arg-2 parsed as offlineplayer
            if all players doesn't contain {_v}:
                send formatted commandError(command, "%arg-1% %arg-2%", player) to player
            else:
                aecFreeze({_v}, player)
        else if arg-1 is "invsee":
            set {_v} to arg-2 parsed as offlineplayer
            if all players doesn't contain {_v}:
                send formatted commandError(command, "%arg-1% %arg-2%", player) to player
            else:
                aecInvSee(player, {_v}, true)
        else if arg-1 is "endersee":
            set {_v} to arg-2 parsed as offlineplayer
            if all players doesn't contain {_v}:
                send formatted commandError(command, "%arg-1% %arg-2%", player) to player
            else:
                aecEnderSee(player, {_v}, true)
        else if arg-1 is "topluck":
            aecTopLuckGuiMain(player)
        else if arg-1 is "reload":
            make console execute command "/sk reload scripts"
            send formatted lang("aec.reloaded", player) to player
            send formatted "§6[§aAntiExploitCore§6]§r §b5m: §a%{aec.temp.5m}% §7/ §b10m: §e%{aec.temp.10m}% §7/ §b15m: §6%{aec.temp.15m}% §7/ §b20m: §4%{aec.temp.20m}%" to player
        else if arg-1 is "vanish":
            aecVanish(player)
        else if arg-1 is "god":
            aecGod(player)
function aecFreeze(target: player, player: player):
    if userData({_target}, "player.freeze") is "true":
        add {_target}'s name to {_args::*}
        send formatted superLang("aec.freeze.youUnFreeze", {_player}, {_args::*}) to {_player}
        send formatted lang("aec.freeze.playerUnFreeze", {_target}) to {_target}
        userData({_target}, "player.freeze", "set", "false")
    else:
        add {_target}'s name to {_args::*}
        send formatted superLang("aec.freeze.youFreeze", {_player}, {_args::*}) to {_player}
        send formatted lang("aec.freeze.playerFreeze", {_target}) to {_target}
        userData({_target}, "player.freeze", "set", "true")
function aecInvSee(player: player, target: player, cmd: boolean=false):
    open {_target}'s inventory to {_player}
    if {_cmd} is false:
        userData({_player}, "data.inv", "set", "manager.aec.topLuck.invsee.main")
function aecEnderSee(player: player, target: player, cmd: boolean=false):
    open {_target}'s ender chest to {_player}
    if {_cmd} is false:
        userData({_player}, "data.inv", "set", "manager.aec.topLuck.endersee.main")
function aecGetLanguage(player: player, split: boolean= true) :: text:
    set {_x} to language of {_player}
    if {_split} is true:
        set {_data::*} to {_x} split by "_"
        set {_x} to {_data::1}
    return {_x}
function aecVanish(player: player):
    if userData({_player}, "player.vanish") is "true":
        loop all players:
            add {_player}'s name to {_args::*}
            if {_player} is not loop-player:
                if loop-player have permission "*":
                    send formatted superLang("aec.vanish.nowVisible", loop-player, {_args::*}) to loop-player
                else:
                    add loop-player to {_g::*}
            send formatted superLang("aec.vanish.join", loop-player, {_args::*}, "language", aecGetLanguage(loop-player)) to loop-player
        reveal {_player} from all players
        userData({_player}, "player.vanish", "set", "false")
    else:
        loop all players:
            add {_player}'s name to {_args::*}
            if {_player} is not loop-player:
                if loop-player have permission "*":
                    send formatted superLang("aec.vanish.nowVanished", loop-player, {_args::*}) to loop-player
                else:
                    add loop-player to {_g::*}
            set {_x} to aecGetLanguage(loop-player)
            send formatted superLang("aec.vanish.quit", loop-player, {_args::*}, "language", {_x}) to loop-player
        hide {_player} from {_g::*}
        userData({_player}, "player.vanish", "set", "true")
function aecGod(player: player):
    if userData({_player}, "player.god") is "true":
        send formatted superLang("aec.god.desactivated", {_player}, {_args::*}) to {_player}
        userData({_player}, "player.god", "set", "false")
    else:
        send formatted superLang("aec.god.activated", {_player}, {_args::*}) to {_player}
        userData({_player}, "player.god", "set", "true")
on join:
    broadcast "§6[§aAntiExploitCore§6]§r %player's name% version ()"
    if userData(player, "player.vanish") is "true":
        set join message to ""
        loop all players:
            add player's name to {_args::*}
            if {_player} is not loop-player:
                if loop-player have permission "*":
                    send formatted superLang("aec.vanish.stillVanished", loop-player, {_args::*}) to loop-player
                    clear {_args::*}
                else:
                    add loop-player to {_g::*}
            reveal the loop-player from all players
            hide the loop-player from {_g::*}
    else:
        set join message to ""
        add player's name to {_args::*}
        loop all players:
            send formatted superLang("aec.vanish.join", loop-player, {_args::*}, "language", aecGetLanguage(loop-player)) to loop-player
        send superLang("aec.vanish.quit", player, {_args::*}, "language", "en") to console
on quit:
    if userData(player, "player.vanish") is "true":
        set quit message to ""
    else:
        set quit message to ""
        add player's name to {_args::*}
        loop all players:
            send formatted superLang("aec.vanish.quit", loop-player, {_args::*}, "language", aecGetLanguage(loop-player)) to loop-player
        send superLang("aec.vanish.quit", player, {_args::*}, "language", "en") to console
on pickup:
    if userData(player, "player.vanish") is "true":
        cancel event
on damage:
    if userData(victim, "player.god") is "true":
        cancel event
    else if userData(victim, "player.vanish") is "true":
        cancel event
function aecTopLuckGuiMain(player: player, debug: boolean=false):
    set {_gui} to genericGui(lang("aec.topLuck.gui.title", {_player}), 6, true)
    set slot 22 of {_gui} to redstone block named "§4Wait.."
    userData({_player}, "data.inv", "set", "manager.aec.topLuck.main")
    open {_gui} to {_player}
    #userData({_player}, "data.inv", "set", "manager.aec.topLuck.main")
    set slot 22 of {_gui} to air
    set {_s} to 0
    loop all players:
        set {_i} to loop-player's skull named "§7%loop-player's name%"
        set line 1 of lore of {_i} to loop-player's uuid
        set line 3 of lore of {_i} to superLang("aec.topLuck.gui.clickToViewMore", {_player}, {_args::*})
        set slot {_s} of {_gui} to {_i}
        add 1 to {_s}
    userData({_player}, "data.inv", "set", "manager.aec.topLuck.main")
every 1 seconds:
    add 1 to {aec.temp.5m}
    add 1 to {aec.temp.10m}
    add 1 to {aec.temp.15m}
    add 1 to {aec.temp.20m}
    if {aec.temp.5m} >= 300:
        loop all players:
            set {_v} to loop-player
            loadUserData({_v})
            loop yaml node keys "player.ores.mined.5m" from "bck.userdata.%{_v}'s uuid%":
                add loop-node to {_ores::*}
            loop {_ores::*}:
                set {_x} to loop-value-2
                set {_v::*} to {_x} split by "."
                set {_w} to {_v::5}
                userData({_v}, "player.ores.mined.5m.%{_w}%", "set", "0")
            send "§6[§aAntiExploitCore§6/§5Top§dLuck§6]§r §7%loop-player's name% §creseted all §b5m" to console
        clear {aec.temp.5m}
    if {aec.temp.10m} >= 600:
        loop all players:
            set {_v} to loop-player
            loadUserData({_v})
            loop yaml node keys "player.ores.mined.10m" from "bck.userdata.%{_v}'s uuid%":
                add loop-node to {_ores::*}
            loop {_ores::*}:
                set {_x} to loop-value-2
                set {_v::*} to {_x} split by "."
                set {_w} to {_v::5}
                userData({_v}, "player.ores.mined.10m.%{_w}%", "set", "0")
            send "§6[§aAntiExploitCore§6/§5Top§dLuck§6]§r §7%loop-player's name% §creseted all §b10m" to console
        clear {aec.temp.10m}
    if {aec.temp.15m} >= 900:
        loop all players:
            set {_v} to loop-player
            loadUserData({_v})
            loop yaml node keys "player.ores.mined.15m" from "bck.userdata.%{_v}'s uuid%":
                add loop-node to {_ores::*}
            loop {_ores::*}:
                set {_x} to loop-value-2
                set {_v::*} to {_x} split by "."
                set {_w} to {_v::5}
                userData({_v}, "player.ores.mined.15m.%{_w}%", "set", "0")
            send "§6[§aAntiExploitCore§6/§5Top§dLuck§6]§r §7%loop-player's name% §creseted all §b15m" to console
        clear {aec.temp.15m}
    if {aec.temp.20m} >= 1200:
        loop all players:
            set {_v} to loop-player
            loadUserData({_v})
            loop yaml node keys "player.ores.mined.20m" from "bck.userdata.%{_v}'s uuid%":
                add loop-node to {_ores::*}
            loop {_ores::*}:
                set {_x} to loop-value-2
                set {_v::*} to {_x} split by "."
                set {_w} to {_v::5}
                userData({_v}, "player.ores.mined.20m.%{_w}%", "set", "0")
            send "§6[§aAntiExploitCore§6/§5Top§dLuck§6]§r §7%loop-player's name% §creseted all §b20m" to console
        clear {aec.temp.20m}
on break:
    set {_b} to event-block
    set {_t} to type of {_b}
    if "%player's gamemode%" is not "creative":
        if "%{_t}%" contain "ore":
            if "%{_t}%" is "lit restone block":
                set {_t} to "restone block"
            loadUserData(player)
            set {_x} to "%{_t}%"
            replace all " " with "_" in {_x}
            set {_c} to userData(player, "player.ores.mined.%{_x}%")
            set {_c5} to userData(player, "player.ores.mined.5m.%{_x}%")
            set {_c10} to userData(player, "player.ores.mined.10m.%{_x}%")
            set {_c15} to userData(player, "player.ores.mined.15m.%{_x}%")
            set {_c20} to userData(player, "player.ores.mined.20m.%{_x}%")
            set {_c} to {_c} parsed as integer
            set {_c5} to {_c5} parsed as integer
            set {_c10} to {_c10} parsed as integer
            set {_c15} to {_c15} parsed as integer
            set {_c20} to {_c20} parsed as integer
            add 1 to {_c}
            add 1 to {_c5}
            add 1 to {_c10}
            add 1 to {_c15}
            add 1 to {_c20}
            userData(player, "player.ores.mined.%{_x}%", "set", "%{_c}%")
            userData(player, "player.ores.mined.5m.%{_x}%", "set", "%{_c5}%")
            userData(player, "player.ores.mined.10m.%{_x}%", "set", "%{_c10}%")
            userData(player, "player.ores.mined.15m.%{_x}%", "set", "%{_c15}%")
            userData(player, "player.ores.mined.20m.%{_x}%", "set", "%{_c20}%")
        else if "%{_t}%" contain "stone block" or "deepslate block" or "netherrack block" or "ancient debris":
            if "%{_t}%" contain "deepslate block":
                set {_t} to "deepslate block"
            loadUserData(player)
            set {_x} to "%{_t}%"
            replace all " " with "_" in {_x}
            set {_c} to userData(player, "player.ores.mined.%{_x}%")
            set {_c5} to userData(player, "player.ores.mined.5m.%{_x}%")
            set {_c10} to userData(player, "player.ores.mined.10m.%{_x}%")
            set {_c15} to userData(player, "player.ores.mined.15m.%{_x}%")
            set {_c20} to userData(player, "player.ores.mined.20m.%{_x}%")
            set {_c} to {_c} parsed as integer
            set {_c5} to {_c5} parsed as integer
            set {_c10} to {_c10} parsed as integer
            set {_c15} to {_c15} parsed as integer
            set {_c20} to {_c20} parsed as integer
            add 1 to {_c}
            add 1 to {_c5}
            add 1 to {_c10}
            add 1 to {_c15}
            add 1 to {_c20}
            userData(player, "player.ores.mined.%{_x}%", "set", "%{_c}%")
            userData(player, "player.ores.mined.5m.%{_x}%", "set", "%{_c5}%")
            userData(player, "player.ores.mined.10m.%{_x}%", "set", "%{_c10}%")
            userData(player, "player.ores.mined.15m.%{_x}%", "set", "%{_c15}%")
            userData(player, "player.ores.mined.20m.%{_x}%", "set", "%{_c20}%")
on skript start:
    set {aec.server.started} to true
    send "§6[§4BCK§6/§aAntiExploitCore§6]§r Enabled.. !" to console
on skript stop:
    set {aec.server.started} to false
    send "§6[§4BCK§6/§aAntiExploitCore§6]§r Disabling.." to console
on inventory click:
    if userData(player, "data.inv") is "false":
        stop
    if userData(player, "data.inv") is "manager.aec.topLuck.main":
        cancel event
        set {_gui} to player's current inventory
        set {_i} to event-slot
        set {_t} to type of {_i}
        set {_n} to display name of {_i}
        set {_u} to {_n}
        set {_a} to item amount of event-slot
        if "%{_t}%" contain "barrier":
            if {_u} contain "Back":
                close player's inventory
        else if "%{_t}%" is "player head item":
            set {_x} to line 1 of lore of {_i} parsed as offlineplayer
            aecTopLuckViewGuiMain({_x}, player)
    else if userData(player, "data.inv") is "manager.aec.topLuck.view.main":
        cancel event
        set {_gui} to player's current inventory
        set {_i} to event-slot
        set {_t} to type of {_i}
        set {_n} to display name of {_i}
        set {_n} to uncolored {_n}
        set {_a} to item amount of event-slot
        set {_gn} to name of player's current inventory
        set {_gn} to uncolored {_gn}
        set {_u} to {_gn} parsed as offlineplayer 
        if "%{_t}%" contain "barrier":
            if {_n} contain "Back":
                aecTopLuckGuiMain(player)
        else if "%{_t}%" is "ender pearl":
            teleport player to {_u}
            play sound "entity.enderman.teleport" with volume 1 for player
            wait 10 ticks
            aecTopLuckViewGuiMain({_u}, player)
        else if "%{_t}%" is "chest":
            play sound "block.chest.open" with volume 1 for player
            aecInvSee(player, {_u})
        else if "%{_t}%" is "ender chest":
            play sound "block.ender_chest.open" with volume 1 for player
            aecEnderSee(player, {_u})
        else if "%{_t}%" is "stick":
            loop 10 times:
                send actionbar superLang("aec.topLuck.view.actionbar", {_u}, {_args::*}) to {_u}
                play sound "entity.firework_rocket.large_blast_far" with volume 1 with pitch 2 at {_u}
                wait 5 ticks
                play sound "entity.firework_rocket.large_blast_far" with volume 1 with pitch 0 at {_u}
                wait 1 seconds
        else if "%{_t}%" is "blue ice block":
            aecFreeze({_u}, player)
            play sound "block.amethyst_block.resonate" with volume 1 with pitch 0 for player
        else if "%{_t}%" is "lava bucket":
            clear {_u}'s inventory
            play sound "block.lava.extinguish" with volume 1 with pitch 0.9 for player
        else if "%{_t}%" is "netherite sword":
            kill {_u}
            play sound "entity.player.death" with volume 1 with pitch 0 for player
on inventory close:
    if userData(player, "data.inv") is "manager.aec.topLuck.invsee.main":
        play sound "block.chest.close" with volume 1 for player
        wait 1 ticks
        aecTopLuckGuiMain(player, true)
    else if userData(player, "data.inv") is "manager.aec.topLuck.endersee.main":
        play sound "block.ender_chest.close" with volume 1 for player
        wait 1 ticks
        aecTopLuckGuiMain(player, true)
on quit:
    if {aec.server.started} is "true":
        userData(player, "server.started", "set", "false")
on join:
    loadUserData(player)
    if {aec.server.started} is true:
        set {_ss} to userData(player, "server.started")
        if userData(player, "server.started") is not "true":
            loop yaml node keys "player.ores.mined" from "bck.userdata.%player's uuid%":
                add loop-node to {_ores::*}
            set {_s} to 0
            loop {_ores::*}:
                set {_x} to loop-value
                set {_v::*} to {_x} split by "."
                set {_w} to {_v::4}
                if "%{_w}%" contain "ore" or "stone_block" or "deepslate" or "netherrack":
                    userData(player, "player.ores.mined.5m.%{_w}%", "set", "0")
                    userData(player, "player.ores.mined.10m.%{_w}%", "set", "0")
                    userData(player, "player.ores.mined.15m.%{_w}%", "set", "0")
                    userData(player, "player.ores.mined.20m.%{_w}%", "set", "0")
            userData(player, "server.started", "set", "true")
    loadUserData(player)
    send "§6[§4BCK§6/§aAntiExploitCore§6]§r %player's name% data loaded !" to console
function aecTopLuckViewGuiMain(target: player, player: player):
    loadUserData({_target})
    set {_gui} to genericGui("§7%{_target}'s name%", 5, true)
    set slot 22 of {_gui} to redstone block named "§4Wait.."
    userData({_player}, "data.inv", "set", "manager.aec.topLuck.view.main")
    open {_gui} to {_player}
    set slot 22 of {_gui} to air
    loop yaml node keys "player.ores.mined" from "bck.userdata.%{_target}'s uuid%":
        add loop-node to {_ores::*}
    set {_s} to 0
    loop {_ores::*}:
        set {_x} to loop-value
        set {_v::*} to {_x} split by "."
        set {_w} to {_v::4}
        if "%{_w}%" doesn't contain "5m" or "10m" or "15m" or "20m":
            set {_c} to userData({_target}, "player.ores.mined.%{_w}%")
            set {_c5} to userData({_target}, "player.ores.mined.5m.%{_w}%")
            set {_c10} to userData({_target}, "player.ores.mined.10m.%{_w}%")
            set {_c15} to userData({_target}, "player.ores.mined.15m.%{_w}%")
            set {_c20} to userData({_target}, "player.ores.mined.20m.%{_w}%")
            set {_stone} to userData({_target}, "player.ores.mined.stone_block")
            set {_deepslate} to userData({_target}, "player.ores.mined.deepslate_block")
            set {_netherrack} to userData({_target}, "player.ores.mined.netherrack_block")
            replace all "_" with " " in {_w}
            set {_i} to {_w} parsed as item
            set {_c} to {_c} parsed as integer
            set {_c5} to {_c5} parsed as integer
            set {_c10} to {_c10} parsed as integer
            set {_c15} to {_c15} parsed as integer
            set {_c20} to {_c20} parsed as integer
            set {_stone} to {_stone} parsed as integer
            set {_deepslate} to {_deepslate} parsed as integer
            set {_netherrack} to {_netherrack} parsed as integer
            if {_c} is not set:
                set {_c} to 1
            if {_c5} is not set:
                set {_c5} to 1
            if {_c10} is not set:
                set {_c10} to 1
            if {_c15} is not set:
                set {_c15} to 1
            if {_c20} is not set:
                set {_c20} to 1
            if {_stone} is not set:
                set {_stone} to 1
            if {_deepslate} is not set:
                set {_deepslate} to 1
            if {_netherrack} is not set:
                set {_netherrack} to 1
            if "%{_w}%" doesn't contain "deepslate" or "nether" or "ancient debris":
                set {_ratio} to aecRatio({_c}, {_stone})
            else if "%{_w}%" contain "deepslate c" or "deepslate i" or "deepslate g" or "deepslate r" or "deepslate e" or "deepslate l":
                set {_ratio} to aecRatio({_c}, {_deepslate})
            else if "%{_w}%" contain "nether g" or "nether q" or "ancient debris":
                set {_ratio} to aecRatio({_c}, {_netherrack})
            else:
                set {_ratio} to aecRatio({_c}, {_c})
            add "%{_c}%" to {_c::*}
            add "%{_ratio}%" to {_c::*}
            set line 1 of lore of {_i} to superLang("aec.topLuck.mined", {_player}, {_c::*})
            if "%{_w}%" doesn't contain "deepslate" or "nether" or "ancient debris":
                set {_ratio5} to aecRatio({_c5}, {_stone})
            else if "%{_w}%" contain "deepslate c" or "deepslate i" or "deepslate g" or "deepslate r" or "deepslate e" or "deepslate l":
                set {_ratio5} to aecRatio({_c5}, {_deepslate})
            else if "%{_w}%" contain "nether g" or "nether q" or "ancient debris":
                set {_ratio5} to aecRatio({_c5}, {_netherrack})
            else:
                set {_ratio5} to aecRatio({_c5}, {_c5})
            add "%{_c5}%" to {_c5::*}
            add "%{_ratio5}%" to {_c5::*}
            set line 2 of lore of {_i} to superLang("aec.topLuck.5m", {_player}, {_c5::*})
            if "%{_w}%" doesn't contain "deepslate" or "nether" or "ancient debris":
                set {_ratio10} to aecRatio({_c10}, {_stone})
            else if "%{_w}%" contain "deepslate c" or "deepslate i" or "deepslate g" or "deepslate r" or "deepslate e" or "deepslate l":
                set {_ratio10} to aecRatio({_c10}, {_deepslate})
            else if "%{_w}%" contain "nether g" or "nether q" or "ancient debris":
                set {_ratio10} to aecRatio({_c10}, {_netherrack})
            else:
                set {_ratio10} to aecRatio({_c10}, {_c10})
            add "%{_c10}%" to {_c10::*}
            add "%{_ratio10}%" to {_c10::*}
            set line 3 of lore of {_i} to superLang("aec.topLuck.10m", {_player}, {_c10::*})
            if "%{_w}%" doesn't contain "deepslate" or "nether" or "ancient debris":
                set {_ratio15} to aecRatio({_c15}, {_stone})
            else if "%{_w}%" contain "deepslate c" or "deepslate i" or "deepslate g" or "deepslate r" or "deepslate e" or "deepslate l":
                set {_ratio15} to aecRatio({_c15}, {_deepslate})
            else if "%{_w}%" contain "nether g" or "nether q" or "ancient debris":
                set {_ratio15} to aecRatio({_c15}, {_netherrack})
            else:
                set {_ratio15} to aecRatio({_c15}, {_c15})
            add "%{_c15}%" to {_c15::*}
            add "%{_ratio15}%" to {_c15::*}
            set line 4 of lore of {_i} to superLang("aec.topLuck.15m", {_player}, {_c15::*})
            if "%{_w}%" doesn't contain "deepslate" or "nether" or "ancient debris":
                set {_ratio20} to aecRatio({_c20}, {_stone})
            else if "%{_w}%" contain "deepslate c" or "deepslate i" or "deepslate g" or "deepslate r" or "deepslate e" or "deepslate l":
                set {_ratio20} to aecRatio({_c20}, {_deepslate})
            else if "%{_w}%" contain "nether g" or "nether q" or "ancient debris":
                set {_ratio20} to aecRatio({_c20}, {_netherrack})
            else:
                set {_ratio20} to aecRatio({_c20}, {_c20})
            add "%{_c20}%" to {_c20::*}
            add "%{_ratio20}%" to {_c20::*}
            set line 5 of lore of {_i} to superLang("aec.topLuck.20m", {_player}, {_c20::*})
            set {_c} to {_c} parsed as integer
            add "%{_ratio}%" to {_ratios::*}
            set line 6 of lore of {_i} to superLang("aec.topLuck.ratio", {_player}, {_ratios::*})
            set slot {_s} of {_gui} to {_i}
            add 1 to {_s}
            clear {_c::*}
            clear {_c5::*}
            clear {_c10::*}
            clear {_c15::*}
            clear {_c20::*}
            clear {_ratios::*}
    set {_tp} to ender pearl named lang("aec.topLuck.view.tp", {_player})
    set {_inv} to chest named lang("aec.topLuck.view.inv", {_player})
    set {_ender} to ender chest named lang("aec.topLuck.view.ender", {_player})
    set {_alert} to stick named lang("aec.topLuck.view.alert", {_player})
    set {_freeze} to blue ice named lang("aec.topLuck.view.freeze", {_player})
    set {_clear} to lava bucket named lang("aec.topLuck.view.clear", {_player})
    set {_kill} to netherite sword named lang("aec.topLuck.view.kill", {_player})
    set slot 28 of {_gui} to {_tp}
    set slot 29 of {_gui} to {_inv}
    set slot 30 of {_gui} to {_ender}
    set slot 31 of {_gui} to {_alert}
    set slot 32 of {_gui} to {_freeze}
    set slot 33 of {_gui} to {_clear}
    set slot 34 of {_gui} to {_kill}
    userData({_player}, "data.inv", "set", "manager.aec.topLuck.view.main")
function aecRatio(ore: integer, block: integer) :: number:
    set {_ratio} to (({_ore} / {_block}) * 100)
    if {_ratio} > 100:
        set {_ratio} to 100
    else if {_ratio} < 0:
        set {_ratio} to 0
    
    return {_ratio}
on any move:
    if userData(player, "player.freeze") is "true":
        cancel event
#                                      tab complete AntiExploitCore                                                                          #
on tab complete of "/AntiExploitCore" or "/aec":
    set tab completions for position 1 to {aec.command.args::*}
    if tab arg-1 is "freeze":
        set tab completions for position 2 to all players
    else if tab arg-1 is "endersee":
        set tab completions for position 2 to all players
    else if tab arg-1 is "invsee":
        set tab completions for position 2 to all players
#                                      aecLoad functions                                                                          #
function aecLoad():
    set {_data::*} to yaml list "data.aec.load.options" from "bck.manager.aec.config"
    if file "plugins/AntiExploitCore/config.yml" doesn't exist:
        send "§6[§4BCK§6/§aAntiExploitCore§6]§r §eInitialization.." to console
        create script "plugins/AntiExploitCore/config.yml"
        write "##                                                                                                                                                                                   " at line 1 to file "plugins/AntiExploitCore/config.yml"
        write "##    ▄████████ ███▄▄▄▄       ███      ▄█          ▄████████ ▀████    ▐████▀    ▄███████▄  ▄█        ▄██████▄   ▄█      ███           ▄████████  ▄██████▄     ▄████████    ▄████████ " at line 2 to file "plugins/AntiExploitCore/config.yml"
        write "##   ███    ███ ███▀▀▀██▄ ▀█████████▄ ███         ███    ███   ███▌   ████▀    ███    ███ ███       ███    ███ ███  ▀█████████▄      ███    ███ ███    ███   ███    ███   ███    ███ " at line 3 to file "plugins/AntiExploitCore/config.yml"
        write "##   ███    ███ ███   ███    ▀███▀▀██ ███▌        ███    █▀     ███  ▐███      ███    ███ ███       ███    ███ ███▌    ▀███▀▀██      ███    █▀  ███    ███   ███    ███   ███    █▀  " at line 4 to file "plugins/AntiExploitCore/config.yml"
        write "##   ███    ███ ███   ███     ███   ▀ ███▌       ▄███▄▄▄        ▀███▄███▀      ███    ███ ███       ███    ███ ███▌     ███   ▀      ███        ███    ███  ▄███▄▄▄▄██▀  ▄███▄▄▄     " at line 5 to file "plugins/AntiExploitCore/config.yml"
        write "## ▀███████████ ███   ███     ███     ███▌      ▀▀███▀▀▀        ████▀██▄     ▀█████████▀  ███       ███    ███ ███▌     ███          ███        ███    ███ ▀▀███▀▀▀▀▀   ▀▀███▀▀▀     " at line 6 to file "plugins/AntiExploitCore/config.yml"
        write "##   ███    ███ ███   ███     ███     ███         ███    █▄    ▐███  ▀███      ███        ███       ███    ███ ███      ███          ███    █▄  ███    ███ ▀███████████   ███    █▄  " at line 7 to file "plugins/AntiExploitCore/config.yml"
        write "##   ███    ███ ███   ███     ███     ███         ███    ███  ▄███     ███▄    ███        ███▌    ▄ ███    ███ ███      ███          ███    ███ ███    ███   ███    ███   ███    ███ " at line 8 to file "plugins/AntiExploitCore/config.yml"
        write "##   ███    █▀   ▀█   █▀     ▄████▀   █▀          ██████████ ████       ███▄  ▄████▀      █████▄▄██  ▀██████▀  █▀      ▄████▀        ████████▀   ▀██████▀    ███    ███   ██████████ " at line 9 to file "plugins/AntiExploitCore/config.yml"
        write "##                                                                                        ▀                                                                  ███    ███              " at line 10 to file "plugins/AntiExploitCore/config.yml"
        write "" at line 11 to file "plugins/AntiExploitCore/config.yml"
        write "##   ___           ___ _            _    _          _       _     _   " at line 12 to file "plugins/AntiExploitCore/config.yml"
        write "##  / __\_   _    / __\ | __ _  ___| | _| | ___ __ (_) __ _| |__ | |_ " at line 13 to file "plugins/AntiExploitCore/config.yml"
        write "## /__\// | | |  /__\// |/ _` |/ __| |/ / |/ / '_ \| |/ _` | '_ \| __|" at line 14 to file "plugins/AntiExploitCore/config.yml"
        write "##/ \/  \ |_| | / \/  \ | (_| | (__|   <|   <| | | | | (_| | | | | |_ " at line 15 to file "plugins/AntiExploitCore/config.yml"
        write "##\_____/\__, | \_____/_|\__,_|\___|_|\_\_|\_\_| |_|_|\__, |_| |_|\__|" at line 16 to file "plugins/AntiExploitCore/config.yml"
        write "##       |___/                                        |___/           " at line 17 to file "plugins/AntiExploitCore/config.yml"
        write "" at line 18 to file "plugins/AntiExploitCore/config.yml"
        set {_x} to 19
        set {_c} to listCounter({_data::*})
        loop {_data::*}:
            write loop-value at line {_x} to file "plugins/AntiExploitCore/config.yml"
            add 1 to {_x}
        wait 3 ticks
        send "§6[§4BCK§6/§aAntiExploitCore§6]§r §eInitialization §nComplete§r§e !" to console
    wait 3 ticks
    load yaml "plugins/AntiExploitCore/config.yml" as "bck.server.aec.config"
    send "§6[§4BCK§6/§aAntiExploitCore§6]§r §aLoaded file succeffully !" to console
    wait 2 ticks

    aecData("antiXray.status", "set", aecServerConfig("antiXray.status"))

    wait 5 ticks
    send "§6[§4BCK§6/§aAntiExploitCore§6]§r §eConfig has been §aupdated §e!" to console

function aecConfig(find: text, mode: text="extract", data: text="") :: text:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.aec.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.aec.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.aec.config"
            save yaml "bck.manager.aec.config"
        else:
            set yaml value "%{_find}%" from "bck.manager.aec.config" to {_data}
            save yaml "bck.manager.aec.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.aec.config" to {_data}
        save yaml "bck.manager.aec.config"
    return "%{_result}%"
function aecData(find: text, mode: text="extract", data: text="") :: text:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.aec.data"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.aec.data"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.aec.data"
            save yaml "bck.manager.aec.data"
        else:
            set yaml value "%{_find}%" from "bck.manager.aec.data" to {_data}
            save yaml "bck.manager.aec.data"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.aec.data" to {_data}
        save yaml "bck.manager.aec.data"
    return "%{_result}%"
function aecServerConfig(find: text, mode: text="extract", data: text="") :: text:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.server.aec.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.server.aec.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.server.aec.config"
            save yaml "bck.server.aec.config"
        else:
            set yaml value "%{_find}%" from "bck.server.aec.config" to {_data}
            save yaml "bck.server.aec.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.server.aec.config" to {_data}
        save yaml "bck.server.aec.config"
    return {_result}